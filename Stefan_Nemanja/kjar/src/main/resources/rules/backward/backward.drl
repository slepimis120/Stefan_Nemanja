import stefan.nemanja.model.models.rules.Position;
import stefan.nemanja.model.models.rules.PositionList;
import java.util.List;
import java.util.ArrayList;

function void updateNeighbors(Position currentPosition, PositionList neighbors, int depth) {
    List<Position> newNeighbors = new ArrayList<>();
    int i = currentPosition.getI();
    int j = currentPosition.getJ();

    newNeighbors.add(new Position(i, j - 1, depth));
    newNeighbors.add(new Position(i, j + 1, depth));

    if (i % 2 == 0) {
        newNeighbors.add(new Position(i - 1, j, depth));
        newNeighbors.add(new Position(i - 1, j + 1, depth));
        newNeighbors.add(new Position(i + 1, j, depth));
        newNeighbors.add(new Position(i + 1, j + 1, depth));
    } else {
        newNeighbors.add(new Position(i - 1, j, depth));
        newNeighbors.add(new Position(i - 1, j - 1, depth));
        newNeighbors.add(new Position(i + 1, j, depth));
        newNeighbors.add(new Position(i + 1, j - 1, depth));
    }

    for (Position newPos : newNeighbors) {
        boolean exists = false;
        boolean depthUpdated = false;

        for (Position pos : neighbors.getPositions()) {
            if (pos.getI() == newPos.getI() && pos.getJ() == newPos.getJ()) {
                exists = true;
                if (pos.getDepth() < newPos.getDepth()) {
                    pos.setDepth(newPos.getDepth());
                    depthUpdated = true;
                }
                break;
            }
        }
    }
}

rule "Calculate Neighbors"
when
    $currentPosition : Position()
    $neighbors : PositionList()
    $depth : Integer()
then
    updateNeighbors($currentPosition, $neighbors, $depth);
end
